// SPDX-License-Identifier: GPL-2.0+

/*
 * Copyright (C) 2016 Freescale Semiconductor, Inc.
 * Copyright 2017-2020 NXP
 */

#include <linux/io.h>
#include <linux/kernel.h>
#include <linux/mutex.h>
#include <linux/sizes.h>

#include "dpu.h"
#include "dpu-prv.h"

#define SSQCNTS			0x0
#define SSQCYCLE		0x408
#define SWRESET			0x40c

#define TCON_CTRL		0x410
#define  CTRL_RST_VAL		0x01401408
#define  BYPASS			BIT(3)

#define RSDSINVCTRL		0x414

/* red: MAPBIT 29-20, green: MAPBIT 19-10, blue: MAPBIT 9-0 */
#define MAPBIT3_0		0x418
#define MAPBIT7_4		0x41c
#define MAPBIT11_8		0x420
#define MAPBIT15_12		0x424
#define MAPBIT19_16		0x428
#define MAPBIT23_20		0x42c
#define MAPBIT27_24		0x430
#define MAPBIT31_28		0x434
#define MAPBIT34_32		0x438
#define MAPBIT3_0_DUAL		0x43c
#define MAPBIT7_4_DUAL		0x440
#define MAPBIT11_8_DUAL		0x444
#define MAPBIT15_12_DUAL	0x448
#define MAPBIT19_16_DUAL	0x44c
#define MAPBIT23_20_DUAL	0x450
#define MAPBIT27_24_DUAL	0x454
#define MAPBIT31_28_DUAL	0x458
#define MAPBIT34_32_DUAL	0x45c

#define SPGPOSON(n)		(0x460 + (n) * 16)
#define SPGMASKON(n)		(0x464 + (n) * 16)
#define SPGPOSOFF(n)		(0x468 + (n) * 16)
#define SPGMASKOFF(n)		(0x46c + (n) * 16)
#define  X(n)			(((n) & 0x7fff) << 16)
#define  Y(n)			((n) & 0x7fff)

#define SMXSIGS(n)		(0x520 + (n) * 8)
#define SMXFCTTABLE(n)		(0x524 + (n) * 8)
#define RESET_OVER_UNFERFLOW	0x580
#define DUAL_DEBUG		0x584

struct dpu_tcon {
	void __iomem *base;
	struct mutex mutex;
	unsigned int id;
	unsigned int index;
	bool inuse;
	struct dpu_soc *dpu;
};

static inline u32 dpu_tcon_read(struct dpu_tcon *tcon, unsigned int offset)
{
	return readl(tcon->base + offset);
}

static inline void dpu_tcon_write(struct dpu_tcon *tcon,
				  unsigned int offset, u32 value)
{
	writel(value, tcon->base + offset);
}

static inline void dpu_tcon_write_mask(struct dpu_tcon *tcon,
				       unsigned int offset, u32 mask, u32 value)
{
	u32 tmp;

	tmp = dpu_tcon_read(tcon, offset);
	tmp &= ~mask;
	dpu_tcon_write(tcon, offset, tmp | value);
}

void dpu_tcon_set_fmt(struct dpu_tcon *tcon)
{
	/*
	 * The pixels reach TCON are always in 30-bit BGR format.
	 * The first bridge always receives pixels in 30-bit RGB format.
	 * So, map the format to MEDIA_BUS_FMT_RGB101010_1X30.
	 */
	dpu_tcon_write(tcon, MAPBIT3_0,   0x17161514);
	dpu_tcon_write(tcon, MAPBIT7_4,   0x1b1a1918);
	dpu_tcon_write(tcon, MAPBIT11_8,  0x0b0a1d1c);
	dpu_tcon_write(tcon, MAPBIT15_12, 0x0f0e0d0c);
	dpu_tcon_write(tcon, MAPBIT19_16, 0x13121110);
	dpu_tcon_write(tcon, MAPBIT23_20, 0x03020100);
	dpu_tcon_write(tcon, MAPBIT27_24, 0x07060504);
	dpu_tcon_write(tcon, MAPBIT31_28, 0x00000908);
}

void dpu_tcon_set_operation_mode(struct dpu_tcon *tcon)
{
	dpu_tcon_write_mask(tcon, TCON_CTRL, BYPASS, 0);
}

void dpu_tcon_cfg_videomode(struct dpu_tcon *tcon, struct drm_display_mode *m)
{
	int hdisplay, hsync_start, hsync_end;
	int vdisplay, vsync_start, vsync_end;
	int y;

	hdisplay = m->hdisplay;
	vdisplay = m->vdisplay;
	hsync_start = m->hsync_start;
	vsync_start = m->vsync_start;
	hsync_end = m->hsync_end;
	vsync_end = m->vsync_end;

	/*
	 * TKT320590:
	 * Turn TCON into operation mode later after the first dumb frame is
	 * generated by DPU.  This makes DPR/PRG be able to evade the frame.
	 */
	dpu_tcon_write_mask(tcon, TCON_CTRL, BYPASS, BYPASS);

	/* dsp_control[0]: hsync */
	dpu_tcon_write(tcon, SPGPOSON(0), X(hsync_start));
	dpu_tcon_write(tcon, SPGMASKON(0), 0xffff);

	dpu_tcon_write(tcon, SPGPOSOFF(0), X(hsync_end));
	dpu_tcon_write(tcon, SPGMASKOFF(0), 0xffff);

	dpu_tcon_write(tcon, SMXSIGS(0), 0x2);
	dpu_tcon_write(tcon, SMXFCTTABLE(0), 0x1);

	/* dsp_control[1]: vsync */
	dpu_tcon_write(tcon, SPGPOSON(1), X(hsync_start) | Y(vsync_start - 1));
	dpu_tcon_write(tcon, SPGMASKON(1), 0x0);

	dpu_tcon_write(tcon, SPGPOSOFF(1), X(hsync_start) | Y(vsync_end - 1));
	dpu_tcon_write(tcon, SPGMASKOFF(1), 0x0);

	dpu_tcon_write(tcon, SMXSIGS(1), 0x3);
	dpu_tcon_write(tcon, SMXFCTTABLE(1), 0x1);

	/* dsp_control[2]: data enable */
	/* horizontal */
	dpu_tcon_write(tcon, SPGPOSON(2), 0x0);
	dpu_tcon_write(tcon, SPGMASKON(2), 0xffff);

	dpu_tcon_write(tcon, SPGPOSOFF(2), X(hdisplay));
	dpu_tcon_write(tcon, SPGMASKOFF(2), 0xffff);

	/* vertical */
	dpu_tcon_write(tcon, SPGPOSON(3), 0x0);
	dpu_tcon_write(tcon, SPGMASKON(3), 0x7fff0000);

	dpu_tcon_write(tcon, SPGPOSOFF(3), Y(vdisplay));
	dpu_tcon_write(tcon, SPGMASKOFF(3), 0x7fff0000);

	dpu_tcon_write(tcon, SMXSIGS(2), 0x2c);
	dpu_tcon_write(tcon, SMXFCTTABLE(2), 0x8);

	/* dsp_control[3]: kachuck */
	y = vdisplay + 1;

	dpu_tcon_write(tcon, SPGPOSON(4), X(0x0) | Y(y));
	dpu_tcon_write(tcon, SPGMASKON(4), 0x0);

	dpu_tcon_write(tcon, SPGPOSOFF(4), X(0x20) | Y(y));
	dpu_tcon_write(tcon, SPGMASKOFF(4), 0x0);

	dpu_tcon_write(tcon, SMXSIGS(3), 0x6);
	dpu_tcon_write(tcon, SMXFCTTABLE(3), 0x2);
}

struct dpu_tcon *dpu_tcon_get(struct dpu_soc *dpu, unsigned int id)
{
	struct dpu_tcon *tcon;
	int i;

	for (i = 0; i < ARRAY_SIZE(dpu->tcon_priv); i++) {
		tcon = dpu->tcon_priv[i];
		if (tcon->id == id)
			break;
	}

	if (i == ARRAY_SIZE(dpu->tcon_priv))
		return ERR_PTR(-EINVAL);

	mutex_lock(&tcon->mutex);

	if (tcon->inuse) {
		mutex_unlock(&tcon->mutex);
		return ERR_PTR(-EBUSY);
	}

	tcon->inuse = true;

	mutex_unlock(&tcon->mutex);

	return tcon;
}

void dpu_tcon_put(struct dpu_tcon *tcon)
{
	if (IS_ERR_OR_NULL(tcon))
		return;

	mutex_lock(&tcon->mutex);

	tcon->inuse = false;

	mutex_unlock(&tcon->mutex);
}

void dpu_tcon_hw_init(struct dpu_soc *dpu, unsigned int index)
{
	/* reset TCON_CTRL to POR default so that TCON works in bypass mode */
	dpu_tcon_write(dpu->tcon_priv[index], TCON_CTRL, CTRL_RST_VAL);
}

int dpu_tcon_init(struct dpu_soc *dpu, unsigned int index,
		  unsigned int id, enum dpu_unit_type type,
		  unsigned long unused, unsigned long base)
{
	struct dpu_tcon *tcon;

	tcon = devm_kzalloc(dpu->dev, sizeof(*tcon), GFP_KERNEL);
	if (!tcon)
		return -ENOMEM;

	dpu->tcon_priv[index] = tcon;

	tcon->base = devm_ioremap(dpu->dev, base, SZ_2K);
	if (!tcon->base)
		return -ENOMEM;

	tcon->dpu = dpu;
	tcon->id = id;
	tcon->index = index;

	mutex_init(&tcon->mutex);

	return 0;
}
