##/bin/sh
#
# Copyright (c) 2000-2001,2005 Silicon Graphics, Inc.
# All Rights Reserved.
#
# Functions useful for quota tests
#

#
# checks that the XFS quota support in the kernel is enabled
# and that we have valid quota user tools installed.
#
_require_quota()
{
    src/feature -q $TEST_DEV
    [ $? -ne 0 ] && _notrun "Installed kernel does not support XFS quota"
    [ -x /usr/sbin/xfs_quota ] || _notrun "Quota user tools not installed"
}

#
# checks that the XFS project quota support in the kernel is enabled.
#
_require_prjquota()
{
    src/feature -p $TEST_DEV
    [ $? -ne 0 ] && _notrun "Installed kernel does not support project quotas"
}

#
# checks for user nobody in /etc/passwd and /etc/group.
#
_require_nobody()
{
    grep -q '^nobody' /etc/passwd
    [ $? -ne 0 ] && _notrun "/etc/passwd does not contain user nobody."

    egrep -q '^no(body|group)' /etc/group
    [ $? -ne 0 ] && _notrun "/etc/group does not contain nobody/nogroup."
}

# create a file as a specific user (uid)
# takes filename, id, type (u/g), blocksize, blockcount
#
_file_as_id()
{
    [ $# != 5 ] && _notrun "broken call to _file_as_id in test $seq"

    if [ $3 = p ]; then
	size=`expr $4 \* $5`;
	echo xfs_io -f -c "chproj $2" -c "pwrite -b $4 0 $size" $1 >>$seq.full
	$XFS_IO_PROG -f -c "chproj $2" -c "pwrite -b $4 0 $size" $1 \
		>>$seq.full 2>&1
	return
    elif [ $3 = u ]; then
	magik='$>'	# perlspeak for effective uid
    elif [ $3 = g ]; then
	magik='$)'	# perlspeak for effective gid
    else
	_notrun "broken type in call to _file_as_id in test $seq"
    fi

    perl <<EOF >>$seq.full 2>&1
	\$| = 1;
	$magik = $2;
	if ($5 == 0) {
	    print "touch $1";
	    exec "touch $1";
	} else {
	    print "dd if=/dev/zero of=$1 bs=$4 count=$5";
	    exec "dd if=/dev/zero of=$1 bs=$4 count=$5";
	}
EOF
# for debugging the above euid change, try... [need write in cwd]
#	exec "dd if=/dev/zero of=$1 bs=$4 count=$5 >>$seq.full 2>&1";
}

_choose_uid()
{
    grep '^nobody' /etc/passwd | perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[2],$a[0] }'
}

_choose_gid()
{
    egrep '^no(body|group)' /etc/group | perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[2],$a[0] }'
}

_choose_prid()
{
    if [ $projid_file == "" ]; then
	projid_file=/etc/projid
    fi
    if [ ! -f $projid_file ]; then
	echo 0
	return
    fi
    perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[1],$a[0] }' \
	$projid_file
}

_qmount()
{
    umount $SCRATCH_DEV >/dev/null 2>&1
    _scratch_mount || _fail "qmount failed"
    chmod ugo+rwx $SCRATCH_MNT
}

_qsetup()
{
    # setup exactly what it is we'll be testing
    enforce=1
    if src/feature -u $SCRATCH_DEV
    then
	type=u ;
	eval `_choose_uid`
	[ ! -f $seq.out ] && ln -s $seq.usrquota $seq.out
    elif src/feature -g $SCRATCH_DEV
    then
	type=g
	eval `_choose_gid`
	[ ! -f $seq.out ] && ln -s $seq.grpquota $seq.out
    elif src/feature -p $SCRATCH_DEV
    then
	type=p
	eval `_choose_prid`
	[ ! -f $seq.out ] && ln -s $seq.prjquota $seq.out
    elif src/feature -U $SCRATCH_DEV
    then
	type=u
	eval `_choose_uid`
	[ ! -f $seq.out ] && ln -s $seq.uqnoenforce $seq.out
	enforce=0
    elif src/feature -G $SCRATCH_DEV
    then
	type=g
	eval `_choose_gid`
	[ ! -f $seq.out ] && ln -s $seq.gqnoenforce $seq.out
	enforce=0
    elif src/feature -P $SCRATCH_DEV
    then
	type=p
	eval `_choose_prid`
	[ ! -f $seq.out ] && ln -s $seq.pqnoenforce $seq.out
	enforce=0
    else
	_notrun "No quota support at mount time"
    fi

    echo "Using output from '" `ls -l $seq.out` "'" >>$seq.full
    echo "and using type=$type id=$id" >>$seq.full
}

# make sure this script returns success
/bin/true
