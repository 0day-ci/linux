##/bin/bash
#
# Copyright (c) 2000-2001,2005 Silicon Graphics, Inc.
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write the Free Software Foundation,
# Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#
# Functions useful for quota tests
#

#
# checks that the generic quota support in the kernel is enabled
# and that we have valid quota user tools installed.
#
_require_quota()
{
    [ -x /usr/bin/quota ] || _notrun "Quota user tools not installed"
    _scratch_mount "-o usrquota,grpquota"
    ret=$?
    umount $SCRATCH_MNT
    [ $ret -ne 0 ] && _notrun "Installed kernel does not support quota"
}

#
# checks that the XFS quota support in the kernel is enabled
# and that we have valid quota user tools installed.
#
_require_xfs_quota()
{
    src/feature -q $TEST_DEV
    [ $? -ne 0 ] && _notrun "Installed kernel does not support XFS quota"
    [ -x /usr/sbin/xfs_quota ] || _notrun "XFS quota user tools not installed"
}

#
# checks that the XFS project quota support in the kernel is enabled.
#
_require_prjquota()
{
    src/feature -p $TEST_DEV
    [ $? -ne 0 ] && _notrun "Installed kernel does not support project quotas"
}

#
# checks for user nobody in /etc/passwd and /etc/group.
#
_require_nobody()
{
    grep -q '^nobody' /etc/passwd
    [ $? -ne 0 ] && _notrun "/etc/passwd does not contain user nobody."

    egrep -q '^no(body|group)' /etc/group
    [ $? -ne 0 ] && _notrun "/etc/group does not contain nobody/nogroup."
}

# create a file as a specific user (uid)
# takes filename, id, type (u/g/p), blocksize, blockcount
#
_file_as_id()
{
    [ $# != 5 ] && _notrun "broken call to _file_as_id in test $seq"

    parent=`dirname $1`
    if [ $3 = p ]; then
	echo PARENT: xfs_io -r -c "chproj $2" -c "chattr +P" $parent >>$seq.full
	$XFS_IO_PROG -r -c "chproj $2" -c "chattr +P" $parent >>$seq.full 2>&1
	magik='$>'	# (irrelevent, above set projid-inherit-on-parent)
    elif [ $3 = u ]; then
	magik='$>'	# perlspeak for effective uid
    elif [ $3 = g ]; then
	magik='$)'	# perlspeak for effective gid
    else
	_notrun "broken type in call to _file_as_id in test $seq"
    fi

    perl <<EOF >>$seq.full 2>&1
	\$| = 1;
	$magik = $2;
	if ($5 == 0) {
	    print "touch $1";
	    exec "touch $1";
	} else {
	    print "dd if=/dev/zero of=$1 bs=$4 count=$5";
	    exec "dd if=/dev/zero of=$1 bs=$4 count=$5";
	}
EOF
# for debugging the above euid change, try... [need write in cwd]
#	exec "dd if=/dev/zero of=$1 bs=$4 count=$5 >>$seq.full 2>&1";

    if [ $3 = p ]; then
	echo PARENT: xfs_io -r -c "chproj 0" -c "chattr -P" $parent >>$seq.full
	$XFS_IO_PROG -r -c "chproj 0" -c "chattr -P" $parent >>$seq.full 2>&1
    fi
}

_choose_uid()
{
    grep '^nobody' /etc/passwd | perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[2],$a[0] }'
}

_choose_gid()
{
    egrep '^no(body|group)' /etc/group | perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[2],$a[0] }'
}

_choose_prid()
{
    if [ "X$projid_file" == "X" ]; then
	projid_file=/etc/projid
    fi
    if [ ! -f $projid_file ]; then
	echo 0
	return
    fi
    perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[1],$a[0] }' \
	$projid_file
}

_qmount()
{
    umount $SCRATCH_DEV >/dev/null 2>&1
    _scratch_mount || _fail "qmount failed"
    chmod ugo+rwx $SCRATCH_MNT
}

_qsetup()
{
    # setup exactly what it is we'll be testing
    enforce=1
    if src/feature -u $SCRATCH_DEV
    then
	type=u ;
	eval `_choose_uid`
	[ ! -f $seq.out ] && ln -s $seq.usrquota $seq.out
    elif src/feature -g $SCRATCH_DEV
    then
	type=g
	eval `_choose_gid`
	[ ! -f $seq.out ] && ln -s $seq.grpquota $seq.out
    elif src/feature -p $SCRATCH_DEV
    then
	type=p
	eval `_choose_prid`
	[ ! -f $seq.out ] && ln -s $seq.prjquota $seq.out
    elif src/feature -U $SCRATCH_DEV
    then
	type=u
	eval `_choose_uid`
	[ ! -f $seq.out ] && ln -s $seq.uqnoenforce $seq.out
	enforce=0
    elif src/feature -G $SCRATCH_DEV
    then
	type=g
	eval `_choose_gid`
	[ ! -f $seq.out ] && ln -s $seq.gqnoenforce $seq.out
	enforce=0
    elif src/feature -P $SCRATCH_DEV
    then
	type=p
	eval `_choose_prid`
	[ ! -f $seq.out ] && ln -s $seq.pqnoenforce $seq.out
	enforce=0
    else
	_notrun "No quota support at mount time"
    fi

    echo "Using output from '" `ls -l $seq.out` "'" >>$seq.full
    echo "and using type=$type id=$id" >>$seq.full
}

#
# Ensures only the given quota mount option is used
#
_qmount_option()
{
	# Replace any user defined quota options
	# with the quota option that we want.
	# Simplest to do this rather than delete existing ones first because
	# of the variety of commas and spaces and multiple -o's
	# that we'd have to cater for. Doesn't matter if we have duplicates.
	# Use "QUOTA" string so that we don't have any substring confusion
	# thanks to "quota" which will match with "uquota" and "gquota" etc.
	export MOUNT_OPTIONS=`echo $MOUNT_OPTIONS \
	| sed   -e 's/uquota/QUOTA/g'      \
		-e 's/usrquota/QUOTA/g'    \
		-e 's/gquota/QUOTA/g'      \
		-e 's/grpquota/QUOTA/g'    \
		-e 's/pquota/QUOTA/g'      \
		-e 's/quota/QUOTA/g'       \
		-e 's/uqnoenforce/QUOTA/g' \
		-e 's/gqnoenforce/QUOTA/g' \
		-e 's/pqnoenforce/QUOTA/g' \
		-e 's/qnoenforce/QUOTA/g'  \
		-e "s/QUOTA/$1/g"`

	# Ensure we have the given quota option - duplicates are fine
	export MOUNT_OPTIONS="$MOUNT_OPTIONS -o $1"
	echo "MOUNT_OPTIONS = $MOUNT_OPTIONS" >>$seq.full
}

# make sure this script returns success
/bin/true
