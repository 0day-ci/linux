##/bin/sh
#
# Functions useful for quota tests
# 
# Copyright (c) 2000-2001 Silicon Graphics, Inc.  All Rights Reserved.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
# 
# This program is distributed in the hope that it would be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# 
# Further, this software is distributed without any warranty that it is
# free of the rightful claim of any third person regarding infringement
# or the like.  Any license provided herein, whether implied or
# otherwise, applies only to this software file.  Patent licenses, if
# any, provided herein do not apply to combinations of this program with
# other software, or any other product whatsoever.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write the Free Software Foundation, Inc., 59
# Temple Place - Suite 330, Boston MA 02111-1307, USA.
# 
# Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
# Mountain View, CA  94043, or:
# 
# http://www.sgi.com 
# 
# For further information regarding this notice, see: 
# 
# http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/
#

# 
# checks that the XFS quota support in the kernel is enabled
# and that we have valid quota user tools installed.
# 
_require_quota()
{
    src/feature -q $TEST_DEV
    [ $? -ne 0 ] && _notrun "Installed kernel does not support XFS quota"
    [ -x /usr/sbin/xfs_quota ] || _notrun "Quota user tools not installed"
}

#
# checks that the XFS project quota support in the kernel is enabled.
# 
_require_prjquota()
{
    src/feature -p $TEST_DEV
    [ $? -ne 0 ] && _notrun "Installed kernel does not support XFS project quotas"
}

#
# checks for user nobody in /etc/passwd and /etc/group.
#
_require_nobody()
{
    grep -q '^nobody' /etc/passwd
    [ $? -ne 0 ] && _notrun "/etc/passwd does not contain user nobody."

    grep -q '^nobody' /etc/group
    [ $? -ne 0 ] && _notrun "/etc/group does not contain user nobody."
}

# create a file as a specific user (uid)
# takes filename, id, type (u/g), blocksize, blockcount
# 
_file_as_id()
{
    [ $# != 5 ] && _notrun "broken call to _file_as_id in test $seq"

    if [ $3 = u ]
    then
	magik='$>'	# perlspeak for effective uid
    elif [ $3 = g ]
    then
	magik='$)'	# perlspeak for effective gid
    else
	_notrun "broken type in call to _file_as_id in test $seq"
    fi

    perl <<EOF >>$seq.full 2>&1
	\$| = 1;
	$magik = $2;
	if ($5 == 0) {
	    print "touch $1";
	    exec "touch $1";
	} else {
	    print "dd if=/dev/zero of=$1 bs=$4 count=$5";
	    exec "dd if=/dev/zero of=$1 bs=$4 count=$5";
	}
EOF
# for debugging the above euid change, try... [need write in cwd]
#	exec "dd if=/dev/zero of=$1 bs=$4 count=$5 >>$seq.full 2>&1";
}

_choose_uid()
{
    grep '^nobody' /etc/passwd | perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[2],$a[0] }'
}

_choose_gid()
{
    grep '^nobody' /etc/group | perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[2],$a[0] }'
}

_choose_prid()
{
    if [ ! -f /etc/projid ]; then
	echo 0
	return
    fi
    perl -ne '@a = split(/:/); END { printf "id=%d name=%s\n", $a[1],$a[0] }' \
	/etc/projid
}

#
# filter to get the guts out
# and make linux and irix similar
#
_filter_repquota()
{
    tee -a $seq.full | $AWK_PROG '
	/File limits/ {
		gotit = 1
	}
	gotit==1 {
		sub(/Disk/, "Block") 
		gsub(/timeleft/, "grace")
		gsub(/[.]0 /,"")
		sub(/- /, "* ")
		sub(/[+] /, "* ")
		gsub(/1week/,"7days")
		gsub(/NOT STARTED/,"")
		gsub(/[ \t]+/, " ")
		if ($0 ~ / [-+]/)
		    $1 = "name"
		if ($0 !~ /^$/)
		    print
		next
	}
    ' | sed -e '/-----------------/d'
}

_qmount()
{
    umount $SCRATCH_DEV >/dev/null 2>&1
    _scratch_mount || _fail "qmount failed"
    chmod ugo+rwx $SCRATCH_MNT
}

_qsetup()
{
    # setup exactly what it is we'll be testing
    enforce=1
    if src/feature -u $SCRATCH_DEV
    then
	type=u ; eval `_choose_uid`; ln -s $seq.usrquota $seq.out
    elif src/feature -g $SCRATCH_DEV
    then
	type=g ; eval `_choose_gid`; ln -s $seq.grpquota $seq.out
    elif src/feature -p $SCRATCH_DEV
    then
	type=p ; eval `_choose_prid`; ln -s $seq.prjquota $seq.out
    elif src/feature -U $SCRATCH_DEV
    then
	type=u ; eval `_choose_uid`; ln -s $seq.uqnoenforce $seq.out
	enforce=0
    elif src/feature -G $SCRATCH_DEV
    then
	type=g ; eval `_choose_gid`; ln -s $seq.gqnoenforce $seq.out
	enforce=0
    elif src/feature -P $SCRATCH_DEV
    then
	type=p ; eval `_choose_prid`; ln -s $seq.pqnoenforce $seq.out
	enforce=0
    else
	_notrun "No quota support at mount time"
    fi

    echo "Using output from '" `ls -l $seq.out` "'" >>$seq.full
    echo "and using type=$type id=$id" >>$seq.full
}


#-----------------------------------------------------------------------------------
#
# wrappers for Linux/IRIX differences
#
_setquota()
{
    _opt_type=$1
    _id=$2
    _bsoft=$3
    _bhard=$4
    _isoft=$5
    _ihard=$6
    _fs=$7

    [ $# -eq 7 ] || _fail "_setquota failed with wrong # args: $*"

    if [ $HOSTOS = "Linux" ]; then
	echo "setquota $_opt_type $_id $_bsoft $_bhard $_isoft $_ihard $_fs" >>$seq.full
	setquota $_opt_type $_id $_bsoft $_bhard $_isoft $_ihard $_fs
    else
	# IRIX
        if [ $_opt_type = "-u" ]; then
		_opt_type=""
		id_param="uid"
	else 
		id_param="gid"
	fi
	echo "/usr/etc/edquota $_opt_type -f $_fs -l $id_param=$_id,bsoft=$_bsoft,bhard=$_bhard,isoft=$_isoft,ihard=$_ihard" >>$seq.full
	/usr/etc/edquota $_opt_type -f $_fs -l $id_param=$_id,bsoft=$_bsoft,bhard=$_bhard,isoft=$_isoft,ihard=$_ihard
    fi
}

_quota()
{
    echo "quota $*" >>$seq.full
    if [ $HOSTOS = "Linux" ]; then
	quota $*
    else
        # clear -u
        args=`echo $*|sed -e 's/-u//'`
	quota -v $args
    fi
}

_repquota()
{
    echo "repquota $*" >>$seq.full
    if [ $HOSTOS = "Linux" ]; then
	repquota $*
    else
        # clear -u
        args=`echo $*|sed -e 's/-u//'`
	repquota -v $args
    fi
}

#-----------------------------------------------------------------------------------

# make sure this script returns success
/bin/true
