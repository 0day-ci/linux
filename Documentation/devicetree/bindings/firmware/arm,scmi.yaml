# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
# Copyright 2021 ARM Ltd.
%YAML 1.2
---
$id: http://devicetree.org/schemas/firmware/arm,scmi.yaml#
$schema: http://devicetree.org/meta-schemas/core.yaml#

title: System Control and Management Interface (SCMI) Message Protocol bindings

maintainers:
  - Sudeep Holla <sudeep.holla@arm.com>

description: |
  The SCMI is intended to allow agents such as OSPM to manage various functions
  that are provided by the hardware platform it is running on, including power
  and performance functions.

  This binding is intended to define the interface the firmware implementing
  the SCMI as described in ARM document number ARM DEN 0056A ("ARM System Control
  and Management Interface Platform Design Document")[0] provide for OSPM in
  the device tree.

  [0] http://infocenter.arm.com/help/topic/com.arm.doc.den0056a/index.html

properties:
  $nodename:
    const: scmi

  compatible:
    oneOf:
      - description: SCMI compliant firmware with mailbox transport
        items:
          - const: arm,scmi
      - description: SCMI compliant firmware with ARM SMC/HVC transport
        items:
          - const: arm,scmi-smc

  mbox-names:
    description: |
      Specifies the mailboxes used to communicate with SCMI compliant
      firmware.
    items:
      - const: tx
      - const: rx

  mboxes:
    description: |
      List of phandle and mailbox channel specifiers. It should contain
      exactly one or two mailboxes, one for transmitting messages("tx")
      and another optional for receiving the notifications("rx") if supported.
    minItems: 1
    maxItems: 2

  shmem:
    description: |
      List of phandle pointing to the shared memory(SHM) area, for each
      transport channel specified.
    minItems: 1
    maxItems: 2

  '#address-cells':
    description: |
      The address cells maps to protocol identifier for a given sub-node.
    const: 1

  '#size-cells':
    description: |
      The size cells are not present as 'reg' property doesn't have any
      size associated with it.
    const: 0

  arm,smc-id:
    $ref: /schemas/types.yaml#/definitions/uint32
    description: |
      SMC id required when using smc or hvc transports

additionalProperties:
  type: object

patternProperties:
  '^protocol@[0-9a-f]+$':
    type: object
    description: |
      Each sub-node represents a protocol supported. If the platform
      supports dedicated communication channel for a particular protocol,
      then corresponding transport properties must be present.

    properties:
      reg:
        maxItems: 1

      '#clock-cells':
        const: 1

      '#reset-cells':
        const: 1

      '#power-domain-cells':
        const: 1

      '#thermal-sensor-cells':
        const: 1

required:
  - compatible
  - shmem

allOf:
  - if:
      properties:
        compatible:
          contains:
            const: arm,scmi
    then:
      required:
        - mboxes
  - if:
      properties:
        compatible:
          contains:
            const: arm,scmi-smc
    then:
      properties:
        interrupts:
          description: |
            The interrupt that indicates message completion by the platform
            rather than by the return of the smc call. This should not be used
            except when the platform requires such behavior.

        interrupt-names:
          const: a2p

      required:
        - arm,smc-id

examples:
  - |
    firmware {
      scmi {
        compatible = "arm,scmi";
        mboxes = <&mhuB 0 0>,
                 <&mhuB 0 1>;
        mbox-names = "tx", "rx";
        shmem = <&cpu_scp_lpri &cpu_scp_hpri>;

        #address-cells = <1>;
        #size-cells = <0>;

        scmi_devpd: protocol@11 {
          reg = <0x11>;
          #power-domain-cells = <1>;
        };

        scmi_dvfs: protocol@13 {
          reg = <0x13>;
          #clock-cells = <1>;
        };

        scmi_clk: protocol@14 {
          reg = <0x14>;
          #clock-cells = <1>;
        };

        scmi_sensors: protocol@15 {
          reg = <0x15>;
          #thermal-sensor-cells = <1>;
        };

        scmi_reset: protocol@16 {
          reg = <0x16>;
          #reset-cells = <1>;
        };

        scmi_voltage: protocol@17 {
          reg = <0x17>;
        };
      };
    };

    soc {
      #address-cells = <2>;
      #size-cells = <2>;

      sram@50000000 {
        compatible = "mmio-sram";
        reg = <0x0 0x50000000 0x0 0x10000>;

        #address-cells = <1>;
        #size-cells = <1>;
        ranges = <0 0x0 0x50000000 0x10000>;

        cpu_scp_lpri: scp-sram-section@0 {
          compatible = "arm,scmi-shmem";
          reg = <0x0 0x200>;
        };

        cpu_scp_hpri: scp-sram-section@200 {
          compatible = "arm,scmi-shmem";
          reg = <0x200 0x200>;
        };
      };

      mhuB: mailbox@2b2f0000 {
        #mbox-cells = <2>;
        compatible = "arm,mhu-doorbell", "arm,primecell";
        reg = <0 0x2b2f0000 0 0x1000>;
        interrupts = <0 36 4>, /* LP-NonSecure */
                     <0 35 4>, /* HP-NonSecure */
                     <0 37 4>; /* Secure */
        clocks = <&clock 0 2 1>;
        clock-names = "apb_pclk";
      };

      gpu@ffe40000 {
        compatible = "amlogic,meson-g12a-mali", "arm,mali-bifrost";
        reg = <0x0 0xffe40000 0x0 0x10000>;
        interrupts = <0 160 4>, <0 161 4>, <0 162 4>;
        interrupt-names = "job", "mmu", "gpu";
        clocks = <&scmi_clk 1>;
        power-domains = <&scmi_devpd 8>;
        resets = <&scmi_reset 0>, <&scmi_reset 1>;
      };

      display@20930000 {
        compatible = "intel,keembay-display";
        reg = <0x0 0x20930000 0x0 0x3000>;
        reg-names = "lcd";
        interrupts = <0 33 4>;
        clocks = <&scmi_clk 0x83>,
                 <&scmi_clk 0x0>;
        clock-names = "clk_lcd", "clk_pll0";

        port {
            disp_out: endpoint {
                remote-endpoint = <&dsi_in>;
            };
        };
      };

      thermal-zones {
        soc-thermal {
          polling-delay-passive = <100>;
          polling-delay = <1000>;
          thermal-sensors = <&scmi_sensors0 3>;

          trips {
            mpu0_crit: mpu0_crit {
              temperature = <125000>; /* milliCelsius */
              hysteresis = <2000>; /* milliCelsius */
              type = "critical";
            };
          };
        };
      };
    };

    cpus {
      #size-cells = <0>;
      #address-cells = <2>;

      cpu@0 {
        device_type = "cpu";
        compatible = "arm,cortex-a57";
        reg = <0x0 0x0>;
        enable-method = "psci";
        clocks = <&scmi_dvfs 0>;
      };
    };

...
