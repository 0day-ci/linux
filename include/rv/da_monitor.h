/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Deterministic automata (DA) monitor functions, to be used togheter
 * with automata models in C generated by the dot2k tool.
 *
 * The dot2k tool is available at tools/tracing/rv/
 *
 * Copyright (C) 2019-2022 Daniel Bristot de Oliveira <bristot@kernel.org>
 */

#include <rv/automata.h>
#include <rv/trace_helpers.h>

struct da_monitor {
	char curr_state;
	bool monitoring;
	void *model;
};

#define MAX_PID		 1024000

/*
 * Generic helpers for all types of deterministic automata monitors.
 */
#define DECLARE_DA_MON_GENERIC_HELPERS(name, type)				\
static char REACT_MSG[1024];							\
										\
static inline char								\
*format_react_msg(type curr_state, type event)					\
{										\
	snprintf(REACT_MSG, 1024,						\
		"rv: monitor %s does not allow event %s on state %s\n",		\
		MODULE_NAME,							\
		model_get_event_name_##name(event),				\
		model_get_state_name_##name(curr_state));			\
	return REACT_MSG;							\
}										\
										\
static void cond_react(char *msg)						\
{										\
	if (rv_##name.react)							\
		rv_##name.react(msg);						\
}										\
										\
static inline void da_monitor_reset_##name(struct da_monitor *da_mon)		\
{										\
	da_mon->monitoring = 0;							\
	da_mon->curr_state = model_get_init_state_##name();			\
}										\
										\
static inline type da_monitor_curr_state_##name(struct da_monitor *da_mon)	\
{										\
	return da_mon->curr_state;						\
}										\
										\
static inline void								\
da_monitor_set_state_##name(struct da_monitor *da_mon, enum states_##name state)\
{										\
	da_mon->curr_state = state;						\
}										\
static inline void da_monitor_start_##name(struct da_monitor *da_mon)		\
{										\
	da_mon->monitoring = 1;							\
}										\
										\
static inline bool da_monitoring_##name(struct da_monitor *da_mon)		\
{										\
	return da_mon->monitoring;						\
}


/*
 * Event handler for implict monitors. Implicity monitor is the one which the
 * handler does not need to specify which da_monitor to manilupulate. Examples
 * of implicit monitor are the per_cpu or the global ones.
 */
#define DECLARE_DA_MON_MODEL_HANDLER_IMPLICIT(name, type)			\
static inline void								\
trace_event_##name(type state, type event, type next_state, bool safe);		\
static inline void trace_error_##name(type state, type event);			\
										\
static inline bool								\
da_event_##name(struct da_monitor *da_mon, enum events_##name event)		\
{										\
	type curr_state = da_monitor_curr_state_##name(da_mon);			\
	type next_state = model_get_next_state_##name(curr_state, event);	\
										\
	if (next_state >= 0) {							\
		da_monitor_set_state_##name(da_mon, next_state);		\
										\
		trace_event_##name(curr_state, event, next_state,		\
				model_is_final_state_##name(next_state));	\
										\
		return true;							\
	}									\
										\
	if (reacting_on)							\
		cond_react(format_react_msg(curr_state, event));		\
										\
	trace_error_##name(curr_state, event);					\
										\
	return false;								\
}										\

/*
 * Event handler for per_task monitors.
 */
#define DECLARE_DA_MON_MODEL_HANDLER_PER_TASK(name, type)			\
										\
static inline void								\
trace_event_##name(pid_t pid, type state, type event,				\
		   type next_state, bool safe);					\
static inline void trace_error_##name(pid_t pid, type state, type event);	\
										\
static inline type								\
da_event_##name(struct da_monitor *da_mon, pid_t pid, enum events_##name event)	\
{										\
	type curr_state = da_monitor_curr_state_##name(da_mon);			\
	type next_state = model_get_next_state_##name(curr_state, event);	\
										\
	if (next_state >= 0) {							\
		da_monitor_set_state_##name(da_mon, next_state);		\
										\
		trace_event_##name(pid, curr_state, event, next_state,		\
				   model_is_final_state_##name(next_state));	\
										\
		return true;							\
	}									\
										\
	if (reacting_on && rv_##name.react)					\
		rv_##name.react(format_react_msg(curr_state, event));		\
										\
	trace_error_##name(pid, curr_state, event);				\
										\
	return false;								\
}

/*
 * Functions to define, init and get a global monitor.
 */
#define DECLARE_DA_MON_INIT_GLOBAL(name, type)					\
										\
static struct da_monitor da_mon_##name;						\
										\
struct da_monitor *da_get_monitor_##name(void)					\
{										\
	return &da_mon_##name;							\
}										\
										\
void da_monitor_reset_all_##name(void)						\
{										\
	da_monitor_reset_##name(da_mon_##name);					\
}										\
										\
static inline void da_monitor_init_##name(void)					\
{										\
	struct da_monitor *da_mon = &da_mon_##name				\
	da_mon->curr_state = model_get_init_state_##name();			\
	da_mon->monitoring = 0;							\
	da_mon->model = model_get_model_##name();				\
}										\

/*
 * Functions to define, init and get a per-cpu monitor.
 *
 * XXX: Make it dynamic.
 */
#define DECLARE_DA_MON_INIT_PER_CPU(name, type)					\
										\
DEFINE_PER_CPU(struct da_monitor, da_mon_##name);				\
										\
struct da_monitor *da_get_monitor_##name(void)					\
{										\
	return this_cpu_ptr(&da_mon_##name);					\
}										\
										\
void da_monitor_reset_all_##name(void)						\
{										\
	struct da_monitor *da_mon;						\
	int cpu;								\
	for_each_cpu(cpu, cpu_online_mask) {					\
		da_mon = per_cpu_ptr(&da_mon_##name, cpu);			\
		da_monitor_reset_##name(da_mon);				\
	}									\
}										\
										\
static inline void da_monitor_init_##name(void)					\
{										\
	struct da_monitor *da_mon;						\
	int cpu;								\
	for_each_cpu(cpu, cpu_online_mask) {					\
		da_mon = per_cpu_ptr(&da_mon_##name, cpu);			\
		da_mon->curr_state = model_get_init_state_##name();		\
		da_mon->monitoring = 0;						\
		da_mon->model = model_get_model_##name();			\
	}									\
}										\


/*
 * Functions to define, init and get a per-task monitor.
 *
 * XXX: Make it dynamic using a list in task_struct (peterz)
 */
#define DECLARE_DA_MON_INIT_PER_TASK(name, type)				\
										\
struct da_monitor da_mon_##name[MAX_PID];					\
										\
static inline struct da_monitor *da_get_monitor_##name(pid_t pid)		\
{										\
	return &da_mon_##name[pid];						\
}										\
										\
void da_monitor_reset_all_##name(void)						\
{										\
	struct da_monitor *mon = da_mon_##name;					\
	int i;									\
	for (i = 0; i < MAX_PID; i++)						\
		da_monitor_reset_##name(&mon[i]);				\
}										\
										\
static void da_monitor_init_##name(void)					\
{										\
	struct da_monitor *mon = da_mon_##name;					\
	int i;									\
										\
	for (i = 0; i < MAX_PID; i++) {						\
		mon[i].curr_state = model_get_init_state_##name();		\
		mon[i].monitoring = 0;						\
		mon[i].model = model_get_model_##name();			\
	}									\
}										\

/*
 * Handle event for implicit monitor: da_get_monitor_##name() will figure out
 * the monitor.
 */
#define DECLARE_DA_MON_MONITOR_HANDLER_IMPLICIT(name, type)			\
										\
static inline void __da_handle_event_##name(struct da_monitor *da_mon,		\
				     enum events_##name event)			\
{										\
	int retval;								\
										\
	if (unlikely(!monitoring_on))						\
		return;								\
										\
	if (unlikely(!rv_##name.enabled))					\
		return;								\
										\
	if (unlikely(!da_monitoring_##name(da_mon)))				\
		return;								\
										\
	retval = da_event_##name(da_mon, event);				\
										\
	if (!retval)								\
		da_monitor_reset_##name(da_mon);				\
}										\
										\
static inline void da_handle_event_##name(enum events_##name event)		\
{										\
	struct da_monitor *da_mon = da_get_monitor_##name();			\
	__da_handle_event_##name(da_mon, event);				\
}										\
										\
static inline bool da_handle_init_event_##name(enum events_##name event)	\
{										\
	struct da_monitor *da_mon;						\
										\
	if (unlikely(!rv_##name.enabled))					\
		return false;							\
										\
	da_mon = da_get_monitor_##name();					\
										\
	if (unlikely(!da_monitoring_##name(da_mon))) {				\
		da_monitor_start_##name(da_mon);				\
		return false;							\
	}									\
										\
	__da_handle_event_##name(da_mon, event);				\
										\
	return true;								\
}										\
										\
static inline bool da_handle_init_run_event_##name(enum events_##name event)	\
{										\
	struct da_monitor *da_mon;						\
										\
	if (unlikely(!rv_##name.enabled))					\
		return false;							\
										\
	da_mon = da_get_monitor_##name();					\
										\
	if (unlikely(!da_monitoring_##name(da_mon)))				\
		da_monitor_start_##name(da_mon);				\
										\
	__da_handle_event_##name(da_mon, event);				\
										\
	return true;								\
}

/*
 * Handle event for per task.
 */
#define DECLARE_DA_MON_MONITOR_HANDLER_PER_TASK(name, type)			\
										\
static inline void								\
__da_handle_event_##name(struct da_monitor *da_mon, pid_t pid,			\
			 enum events_##name event)				\
{										\
	int retval;								\
										\
	if (unlikely(!monitoring_on))						\
		return;								\
										\
	if (unlikely(!rv_##name.enabled))					\
		return;								\
										\
	if (unlikely(!da_monitoring_##name(da_mon)))				\
		return;								\
										\
	retval = da_event_##name(da_mon, pid, event);				\
										\
	if (!retval)								\
		da_monitor_reset_##name(da_mon);				\
}										\
										\
static inline void								\
da_handle_event_##name(pid_t pid, enum events_##name event)			\
{										\
	struct da_monitor *da_mon = da_get_monitor_##name(pid);			\
	__da_handle_event_##name(da_mon, pid, event);				\
}										\
										\
static inline bool								\
da_handle_init_event_##name(pid_t pid, enum events_##name event)		\
{										\
	struct da_monitor *da_mon;						\
										\
	if (unlikely(!rv_##name.enabled))					\
		return false;							\
										\
	da_mon = da_get_monitor_##name(pid);					\
										\
	if (unlikely(!da_monitoring_##name(da_mon))) {				\
		da_monitor_start_##name(da_mon);				\
		return false;							\
	}									\
										\
	__da_handle_event_##name(da_mon, pid, event);				\
										\
	return true;								\
}

/*
 * Entry point for the global monitor.
 */
#define DECLARE_DA_MON_GLOBAL(name, type)					\
										\
DECLARE_AUTOMATA_HELPERS(name, type);						\
										\
DECLARE_DA_MON_GENERIC_HELPERS(name, type);					\
										\
DECLARE_DA_MON_MODEL_HANDLER_IMPLICIT(name, type);				\
										\
DECLARE_DA_MON_INIT_PER_CPU(name, type);					\
										\
DECLARE_DA_MON_MONITOR_HANDLER_IMPLICIT(name, type);

/*
 * Entry point for the per-cpu monitor.
 */
#define DECLARE_DA_MON_PER_CPU(name, type)					\
										\
DECLARE_AUTOMATA_HELPERS(name, type);						\
										\
DECLARE_DA_MON_GENERIC_HELPERS(name, type);					\
										\
DECLARE_DA_MON_MODEL_HANDLER_IMPLICIT(name, type);				\
										\
DECLARE_DA_MON_INIT_PER_CPU(name, type);					\
										\
DECLARE_DA_MON_MONITOR_HANDLER_IMPLICIT(name, type);

/*
 * Entry point for the per-task monitor.
 */
#define DECLARE_DA_MON_PER_TASK(name, type)					\
										\
DECLARE_AUTOMATA_HELPERS(name, type);						\
										\
DECLARE_DA_MON_GENERIC_HELPERS(name, type);					\
										\
DECLARE_DA_MON_MODEL_HANDLER_PER_TASK(name, type);				\
										\
DECLARE_DA_MON_INIT_PER_TASK(name, type);					\
										\
DECLARE_DA_MON_MONITOR_HANDLER_PER_TASK(name, type);
