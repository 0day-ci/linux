##/bin/sh
#
# Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
# 
# This program is distributed in the hope that it would be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# 
# Further, this software is distributed without any warranty that it is
# free of the rightful claim of any third person regarding infringement
# or the like.  Any license provided herein, whether implied or
# otherwise, applies only to this software file.  Patent licenses, if
# any, provided herein do not apply to combinations of this program with
# other software, or any other product whatsoever.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write the Free Software Foundation, Inc., 59
# Temple Place - Suite 330, Boston MA 02111-1307, USA.
# 
# Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
# Mountain View, CA  94043, or:
# 
# http://www.sgi.com 
# 
# For further information regarding this notice, see: 
# 
# http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/
#

#
# setup and check for config parameters, and in particular
#
# TEST_DIR		- scratch test directory that is in an already
#		  	  mounted XFS file system, needs to be be world
#			  writeable
# TEST_DEV		- device for file system containing TEST_DIR
# SCRATCH_DEV	        - device you can make a scratch file system on
# SCRATCH_MNT	        - mount point for scratch file system
# 
# and optionally:
# SCRATCH_LOGDEV	- scratch log device for external log testing
# SCRATCH_RTDEV	        - scratch rt dev
# TEST_LOGDEV		- test log device for external log testing
# TEST_RTDEV	        - test rt dev
# TAPE_DEV		- the tape device for the xfsdump tests
# RMT_TAPE_DEV		- the remote tape device for the xfsdump tests
# RMT_IRIXTAPE_DEV	- the IRIX remote tape device for the xfsdump tests
# RMT_TAPE_USER		- remote user for tape device
#
# - These can be added to known_hosts() below or a separate local
#   configuration file can be used (using the HOST_OPTIONS variable).
# - This script is shared by the stress test system and the auto-qa
#   system (includes both regression test and benchmark components).
# - TEST_DEV & TEST_DIR must be assigned.
# - this script shouldn't make any assertions about filesystem
#   validity or mountedness.
#

# Warning: don't put freeware before /usr/bsd on IRIX coz you'll
#          get the wrong hostname and set your system name to -s  :)
[ -d /usr/bsd ] && PATH=$PATH:/usr/bsd
[ -d /usr/freeware/bin ] && PATH=$PATH:/usr/freeware/bin
PATH=".:$PATH"

HOST=`hostname -s`
HOSTOS=`uname -s`
[ "$HOSTOS" = "IRIX64" ] && HOSTOS="IRIX"

MODULAR=0		# using XFS as a module or not
BOOT="/boot"		# install target for kernels
export EXTRA=${EXTRA:=xfs-qa}

# general parameters (mainly for auto-qa)
SOAK_PROC=3		# -p option to fsstress
SOAK_STRESS=10000	# -n option to fsstress
SOAK_PASSES=-1		# count of repetitions of fsstress (while soaking)
EMAIL=root@localhost	# where auto-qa will send its status messages
export HOST_OPTIONS=${HOST_OPTIONS:=local.config}
export CHECK_OPTIONS=${CHECK_OPTIONS:="-g auto"}
export BENCH_PASSES=${BENCH_PASSES:=5}
export XFS_MKFS_OPTIONS=${XFS_MKFS_OPTIONS:=-bsize=4096}

#export DEBUG=${DEBUG:=...} # arbitrary CFLAGS really.
export MALLOCLIB=${MALLOCLIB:=/usr/lib/libefence.a}
export LOCAL_CONFIGURE_OPTIONS=${LOCAL_CONFIGURE_OPTIONS:=--enable-readline=yes}

# $1 = prog to look for, $2* = default pathnames if not found in $PATH
set_prog_path()
{
    p=`which $1 2> /dev/null`
    if [ -n "$p" -a -x "$p" ]
    then
	echo $p
	return 0
    fi
    p=$1

    shift
    for f
    do
	if [ -x $f ]
	then
	    echo $f
	    return 0
	fi
    done

    echo ""
    return 1
}

_fatal()
{
    echo "$*"
    status=1
    exit 1
}

export MKFS_PROG="`set_prog_path mkfs`"
[ "$MKFS_PROG" = "" ] && _fatal "mkfs not found"

export AWK_PROG="`set_prog_path awk`"
[ "$AWK_PROG" = "" ] && _fatal "awk not found"

export MOUNT_PROG="`set_prog_path mount`"
[ "$MOUNT_PROG" = "" ] && _fatal "mount not found"

export UMOUNT_PROG="`set_prog_path umount`"
[ "$UMOUNT_PROG" = "" ] && _fatal "umount not found"

export NSLOOKUP_PROG="`set_prog_path nslookup`"
[ "$NSLOOKUP_PROG" = "" ] && _fatal "nslookup not found"

export PERL_PROG="`set_prog_path perl`"
[ "$PERL_PROG" = "" ] && _fatal "perl not found"

export SED_PROG="`set_prog_path sed`"
[ "$SED_PROG" = "" ] && _fatal "sed not found"

export PS_ALL_FLAGS="-ef"

export DF_PROG="`set_prog_path df`"
[ "$DF_PROG" = "" ] && _fatal "df not found"
[ "$HOSTOS" = "Linux" ] && export DF_PROG="$DF_PROG -T"

export XFS_LOGPRINT_PROG="`set_prog_path xfs_logprint`"
export XFS_REPAIR_PROG="`set_prog_path xfs_repair`"
export XFS_CHECK_PROG="`set_prog_path xfs_check`"
export XFS_DB_PROG="`set_prog_path xfs_db`"

case "$HOSTOS" in
    IRIX*)
	   export MKFS_XFS_PROG="`set_prog_path mkfs_xfs`"
	   export MKFS_UDF_PROG="`set_prog_path mkfs_udf`" 
	   export XFS_FSR_PROG="`set_prog_path /usr/etc/fsr_xfs`"
	   export MKFS_NFS_PROG="false" 
	   ;;
    Linux)
	   export MKFS_XFS_PROG="`set_prog_path mkfs.xfs`"
	   export MKFS_UDF_PROG="`set_prog_path mkudffs`"
	   export XFS_FSR_PROG="`set_prog_path xfs_fsr`"
	   export MKFS_NFS_PROG="false" 
	   ;;
esac

known_hosts()
{
	case "$HOST"
	in
	    bruce)
		MODULAR=0
		EMAIL="nathans@larry"
		SCRATCH_MNT=/mnt/xfs0
		SCRATCH_DEV=/dev/sdb5
		#SCRATCH_RTDEV=/dev/sdc1
		SCRATCH_LOGDEV=/dev/sda11
		TEST_DIR=/mnt/xfs1
		TEST_DEV=/dev/sdc3
		#TEST_RTDEV=/dev/sdb6
		TEST_LOGDEV=/dev/sda9
		TAPE_DEV=/dev/st0
		RMT_TAPE_DEV=bruce:/dev/st0
		RMT_IRIXTAPE_DEV=snort:/dev/tape
		RMT_TAPE_USER=guest
		;;
	    sherman)
		TEST_DEV=/dev/sda10
		TEST_DIR=/mnt/xfs1
		SCRATCH_DEV=/dev/sda9
		SCRATCH_MNT=/mnt/xfs0
		;;
	    flutz)
		MODULAR=0
		EMAIL="nathans@larry"
		TEST_DEV=/dev/sda5
		TEST_LOGDEV=/dev/sda9
		TEST_DIR=/xfsqa1
		SCRATCH_DEV=/dev/sda6
		SCRATCH_LOGDEV=/dev/sda7
		SCRATCH_MNT=/xfsqa2
		TAPE_DEV=/dev/st0
		RMT_TAPE_DEV=bruce:/dev/st0
		RMT_IRIXTAPE_DEV=snort:/dev/tape
		RMT_TAPE_USER=guest
		;;
	    frodo)
		MODULAR=0
		EMAIL="nathans@larry"
		TEST_DEV=/dev/hda6
		TEST_DIR=/mnt/test
		SCRATCH_DEV=/dev/hda7
		SCRATCH_MNT=/mnt/scratch
		SCRATCH_LOGDEV=/dev/hda9
		;;
	    goldfish)
		MODULAR=0
		TEST_DEV=/dev/hdc1
		TEST_DIR=/mnt/xfs0
		SCRATCH_DEV=/dev/hdc2
		SCRATCH_MNT=/mnt/xfs1
		SCRATCH_LOGDEV=/dev/hdc3
		;;
	    lord)
		TEST_DIR=/xfs
		TEST_DEV=/dev/sda1
		SCRATCH_DEV=/dev/sda5
		SCRATCH_LOGDEV=/dev/sda6
		SCRATCH_MNT=/xfs1
		;;
	    burst)
		TEST_DIR=/xfs
		TEST_DEV=/dev/hda3
		SCRATCH_DEV=/dev/hda7
		SCRATCH_MNT=/scratch
		;;
	    lumpy)
		TEST_DEV=/dev/sdc5
		TEST_DIR=/mnt/scratch_0
		SCRATCH_DEV=/dev/sdc7
		SCRATCH_MNT=/mnt/scratch_2
		;;
	    bongo)
		TEST_DEV=/dev/hda8
		TEST_DIR=/xfs1
		SCRATCH_DEV=/dev/hda9
		SCRATCH_MNT=/xfs2
		SCRATCH_LOGDEV=/dev/hda10
		SCRATCH_RTDEV=/dev/hda11
		;;
	    surly)
		TEST_DEV=/dev/hda9
		TEST_DIR=/mnt/xfs1
		SCRATCH_DEV=/dev/hda8
		SCRATCH_MNT=/mnt/xfs0
		SCRATCH_LOGDEV=/dev/hda10
		TAPE_DEV=/dev/st0
		RMT_TAPE_DEV=fuzzy:/dev/st0
		RMT_IRIXTAPE_DEV=blub:/dev/tape
		RMT_TAPE_USER=guest
		;;
	    permit)
		TEST_DEV=/dev/sdc1
		TEST_DIR=/mnt/xfs0
		SCRATCH_DEV=/dev/sdd1
		SCRATCH_MNT=/mnt/xfs1
		;;
	    indra)
		TEST_DEV=/dev/sdb1
		TEST_DIR=/mnt/xfs0
		SCRATCH_DEV=/dev/sdb2
		SCRATCH_MNT=/mnt/xfs1
		;;
	    usermode)
		TEST_DEV=/dev/ubd/1
		TEST_DIR=/mnt/test
		SCRATCH_DEV=/dev/ubd/2
		SCRATCH_MNT=/mnt/scratch
		SCRATCH_RTDEV=/dev/ubd/3
		SCRATCH_LOGDEV=/dev/ubd/4
		;;
	    lite)
		TEST_DEV=/dev/sda1
		TEST_DIR=/mnt/sda1
		SCRATCH_DEV=/dev/sda2
		SCRATCH_MNT=/mnt/sda2
		SCRATCH_LOGDEV=/dev/sda3
		SCRATCH_RTDEV=/dev/sda4
		;;
	    dmfnt2)
		TEST_DEV=/dev/sda6
		TEST_DIR=/mnt/test
		SCRATCH_DEV=/dev/sdc6
		SCRATCH_MNT=/mnt/scratch
		TAPE_DEV=/dev/st0
		RMT_TAPE_DEV=longhorn:/dev/tape
		# RMT_IRIXTAPE_DEV=longhorn:/dev/tape
		RMT_TAPE_USER=guest
		;;
	    lab343)
		MODULAR=0
		EMAIL="hch@sgi.com"
		TEST_DEV=/dev/sdb1
		SCRATCH_DEV=/dev/sdb2
		SCRATCH_LOGDEV=/dev/sdb5
		SCRATCH_RTDEV=/dev/sdb6
		TEST_DIR=/qa/test
		SCRATCH_MNT=/qa/scratch
		;;
	    icy)
		MODULAR=0
		EMAIL="ajones@sgi.com"
		TEST_DIR=/mnt/test
		TEST_DEV=/dev/sda3
		#TEST_LOGDEV=/dev/sda9
		#TEST_RTDEV=/dev/sda10
		SCRATCH_MNT=/mnt/scratch
		SCRATCH_DEV=/dev/sda5
		SCRATCH_LOGDEV=/dev/sda8
		SCRATCH_RTDEV=/dev/sda7
		TAPE_DEV=/dev/st0
		RMT_IRIXTAPE_DEV=snort:/dev/tape
		RMT_TAPE_DEV=icy:/dev/st0
		RMT_TAPE_USER=guest
		;;
            dribble)
                MODULAR=0
                EMAIL="ajones@sgi.com"
                TEST_DIR=/mnt/test
                TEST_DEV=/dev/dsk/dks0d2s0
                #TEST_LOGDEV=
                SCRATCH_MNT=/mnt/scratch
                SCRATCH_DEV=/dev/dsk/dks0d2s1
                #SCRATCH_LOGDEV=
                #SCRATCH_RTDEV=
                TAPE_DEV=/dev/tape
                RMT_TAPE_DEV=icy:/dev/st0
                RMT_TAPE_USER=guest
                RMT_IRIXTAPE_DEV=snort:/dev/tape        
                ;;
	    emu)
		MODULAR=0
		EMAIL="ajones@sgi.com"
		TEST_DIR=/mnt/test
		TEST_DEV=/dev/sdb1
		SCRATCH_MNT=/mnt/scratch
		SCRATCH_DEV=/dev/sdb2
		;;

	    *)	
		echo "Error: need to define parameters for host $HOST"
		exit 1
		;;
	esac
}

if [ -f "$HOST_OPTIONS" ]; then
    . "$HOST_OPTIONS"
else
    known_hosts
fi

echo $TEST_DEV | grep -q ":" > /dev/null 2>&1
if [ ! -b "$TEST_DEV" -a "$?" != "0" ]
then
    echo "common.config: Error: \$TEST_DEV ($TEST_DEV) is not a block device or a NFS filesystem"
    exit 1
fi

if [ ! -d "$TEST_DIR" ]
then
    echo "common.config: Error: \$TEST_DIR ($TEST_DIR) is not a directory"
    exit 1
fi

echo $SCRATCH_DEV | grep -q ":" > /dev/null 2>&1
if [ ! -z "$SCRATCH_DEV" -a ! -b "$SCRATCH_DEV" -a "$?" != "0" ]
then
    echo "common.config: Error: \$SCRATCH_DEV ($SCRATCH_DEV) is not a block device or a NFS filesystem"
    exit 1
fi

if [ ! -z "$SCRATCH_MNT" -a ! -d "$SCRATCH_MNT" ]
then
    echo "common.config: Error: \$SCRATCH_MNT ($SCRATCH_MNT) is not a directory"
    exit 1
fi

_readlink()
{
    if [ $# -ne 1 ]
    then
	echo "Usage: _readlink filename" 1>&2
	exit 1
    fi

    perl -e "\$in=\"$1\";" -e '
	$lnk = readlink($in);
	if ($lnk =~ m!^/.*!) {
	  print "$lnk\n";
	}
	else {
	  chomp($dir = `dirname $in`);
	  print "$dir/$lnk\n";
	}'
}

# if devfs is running expand the full /dev/.. pathname - this is what will be
# returned by utilities such as mount
[ -L "$TEST_DEV" ] && TEST_DEV=`_readlink $TEST_DEV`
[ -L "$SCRATCH_DEV" ] && SCRATCH_DEV=`_readlink $SCRATCH_DEV`
[ -L "$SCRATCH_LOGDEV" ] && SCRATCH_LOGDEV=`_readlink $SCRATCH_LOGDEV`
[ -L "$SCRATCH_RTDEV" ] && SCRATCH_RTDEV=`_readlink $SCRATCH_LOGDEV`

# make sure this script returns success
/bin/true
